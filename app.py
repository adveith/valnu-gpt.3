from flask import Flask, request, jsonify, render_template
import tensorflow as tf
import pickle
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing.text import Tokenizer
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import numpy as np
import re
import psycopg2
import nltk
from chatbot import extract_cwe_id, extract_detail_type, get_vulnerability_details

# Initialize NLTK and download the VADER lexicon
nltk.download('vader_lexicon')

app = Flask(__name__)

# Load the tokenizer
with open('models/tokenizer.pickle', 'rb') as handle:
    tokenizer = pickle.load(handle)

# Load the pre-trained TensorFlow model for intent classification
model = tf.keras.models.load_model('models/intent_model.h5')

# Instantiate the VADER sentiment intensity analyzer
analyzer = SentimentIntensityAnalyzer()

# Establish connection to the PostgreSQL database
try:
    conn = psycopg2.connect(
        dbname="postgres",
        user="postgres",
        password="adi",
        host="localhost",
        port="5432"
    )
except psycopg2.Error as e:
    print("Error connecting to the database:", e)

def preprocess_input(user_input, max_len):
    """
    Preprocesses user input for model prediction.

    Args:
        user_input (str): User input.
        max_len (int): Maximum length for padding sequences.

    Returns:
        np.array: Preprocessed input ready for model prediction.
    """
    sequences = tokenizer.texts_to_sequences([user_input])
    padded = pad_sequences(sequences, maxlen=max_len, padding='post', truncating='post')
    return padded

def predict_intent(user_input, model, max_len):
    """
    Predicts the intent of the user input using a pre-trained TensorFlow model.

    Args:
        user_input (str): User input.
        model (tf.keras.Model): Pre-trained TensorFlow model for intent classification.
        max_len (int): Maximum length for padding sequences.

    Returns:
        int: Predicted intent index.
    """
    processed_input = preprocess_input(user_input, max_len)
    prediction = model.predict(processed_input)
    intent = np.argmax(prediction)  # Assuming your model outputs probabilities for each intent
    return intent

def get_sentiment_label(sentiment_scores):
    """
    Determines the sentiment label based on sentiment scores.

    Args:
        sentiment_scores (dict): Dictionary containing sentiment scores.

    Returns:
        str: Sentiment label ('positive', 'negative', or 'neutral').
    """
    compound_score = sentiment_scores['compound']
    if compound_score >= 0.05:
        return 'positive'
    elif compound_score <= -0.05:
        return 'negative'
    else:
        return 'neutral'

def chatbot_response(user_input):
    """
    Generates a response based on user input.

    Args:
        user_input (str): User input.

    Returns:
        str: Response generated by the chatbot.
    """
    try:
        # Intent classification using TensorFlow model
        intent = predict_intent(user_input, model, max_len=20)

        # Sentiment analysis using NLTK's VADER module
        sentiment_scores = analyzer.polarity_scores(user_input)
        sentiment_label = get_sentiment_label(sentiment_scores)

        # Respond based on detected intent and sentiment
        if intent == 0:
            # Extract CWE ID and detail type
            cwe_id = extract_cwe_id(user_input)
            detail_type = extract_detail_type(user_input)
            
            if cwe_id:
                # Query vulnerability details from the database
                details = get_vulnerability_details(cwe_id, detail_type)
                if isinstance(details, dict) and 'error' in details:
                    return details['error']
                else:
                    response = f"Details for {cwe_id}:\n"
                    for key, value in details.items():
                        response += f"{key}: {value}\n"
                    return response
            else:
                return "Could not extract CWE ID from the input. Please provide a valid CWE ID."

        elif intent == 1:
            # Implement logic for responding to intent 1 (if needed)
            return "Implement logic for intent 1"

        # Add more conditional statements for other intents

        # Default response
        return "I'm sorry, I didn't understand that. Can you please rephrase?"

    except Exception as e:
        return f"An error occurred: {str(e)}"

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/chat', methods=['POST'])
def chat():
    try:
        user_input = request.json.get("message")
        if not user_input:
            return jsonify({"error": "No input provided"}), 400

        response = chatbot_response(user_input)
        return jsonify({"response": response})

    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
