import tensorflow as tf
import pickle
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.preprocessing.text import Tokenizer
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import numpy as np
import re
import psycopg2
import nltk

# Initialize NLTK and download the VADER lexicon
nltk.download('vader_lexicon')

# Load the tokenizer
with open('models/tokenizer.pickle', 'rb') as handle:
    tokenizer = pickle.load(handle)

# Load the pre-trained TensorFlow model for intent classification
model = tf.keras.models.load_model('models/intent_model.h5')

# Instantiate the VADER sentiment intensity analyzer
analyzer = SentimentIntensityAnalyzer()

# Establish connection to the PostgreSQL database
try:
    conn = psycopg2.connect(
        dbname="postgres",
        user="postgres",
        password="adi",
        host="localhost",
        port="5432"
    )
except psycopg2.Error as e:
    print("Error connecting to the database:", e)

def preprocess_input(user_input, max_len):
    """
    Preprocesses user input for model prediction.

    Args:
        user_input (str): User input.
        max_len (int): Maximum length for padding sequences.

    Returns:
        np.array: Preprocessed input ready for model prediction.
    """
    sequences = tokenizer.texts_to_sequences([user_input])
    padded = pad_sequences(sequences, maxlen=max_len, padding='post', truncating='post')
    return padded

def predict_intent(user_input, model, max_len):
    """
    Predicts the intent of the user input using a pre-trained TensorFlow model.

    Args:
        user_input (str): User input.
        model (tf.keras.Model): Pre-trained TensorFlow model for intent classification.
        max_len (int): Maximum length for padding sequences.

    Returns:
        int: Predicted intent index.
    """
    processed_input = preprocess_input(user_input, max_len)
    prediction = model.predict(processed_input)
    intent = np.argmax(prediction)  # Assuming your model outputs probabilities for each intent
    return intent

def get_sentiment_label(sentiment_scores):
    """
    Determines the sentiment label based on sentiment scores.

    Args:
        sentiment_scores (dict): Dictionary containing sentiment scores.

    Returns:
        str: Sentiment label ('positive', 'negative', or 'neutral').
    """
    compound_score = sentiment_scores['compound']
    if compound_score >= 0.05:
        return 'positive'
    elif compound_score <= -0.05:
        return 'negative'
    else:
        return 'neutral'

def extract_cwe_id(user_input):
    """
    Extracts CWE ID from user input using regex.

    Args:
        user_input (str): User input containing CWE ID.

    Returns:
        str: CWE ID if found, otherwise None.
    """
    match = re.search(r'CWE-\d+', user_input)
    if match:
        return match.group(0)
    return None

def get_vulnerability_details(cwe_id, detail_type=None):
    """
    Retrieves vulnerability details from the database based on CWE ID.

    Args:
        cwe_id (str): CWE ID to search for.
        detail_type (str): Specific detail type to retrieve (e.g., 'mitigations').

    Returns:
        dict: Formatted vulnerability details if found, otherwise a message indicating no details found.
    """
    try:
        cur = conn.cursor()
        query = "SELECT name, description, detection_methods, potential_mitigations FROM vulnerabilities WHERE cwe = %s"
        cur.execute(query, (cwe_id,))
        row = cur.fetchone()

        if row:
            name, description, detection_methods, potential_mitigations = row
            response = {
                "Name": name,
                "Description": description,
                "Detection Methods": detection_methods,
                "Potential Mitigations": potential_mitigations
            }
            if detail_type:
                return {detail_type: response.get(detail_type.replace(" ", "_"))}
            return response
        else:
            return {"error": "No details found for this CWE ID."}
    except psycopg2.Error as e:
        print("Error retrieving data from the database:", e)
        return {"error": "An error occurred while retrieving data."}
    finally:
        if 'cur' in locals():
            cur.close()

def extract_detail_type(user_input):
    """
    Extracts the detail type from the user input.

    Args:
        user_input (str): User input.

    Returns:
        str: Detail type if found, otherwise None.
    """
    detail_types = ['description', 'detection methods', 'potential mitigations']
    for detail_type in detail_types:
        if detail_type in user_input.lower():
            return detail_type.replace(" ", "_").capitalize()
    return None

def chatbot_response(user_input):
    """
    Generates a response based on user input.

    Args:
        user_input (str): User input.

    Returns:
        str: Response generated by the chatbot.
    """
    try:
        print(f"Received input: {user_input}")

        # Intent classification using TensorFlow model
        intent = predict_intent(user_input, model, max_len=20)
        print(f"Detected intent index: {intent}")

        # Sentiment analysis using NLTK's VADER module
        sentiment_scores = analyzer.polarity_scores(user_input)
        sentiment_label = get_sentiment_label(sentiment_scores)
        print(f"Detected sentiment: {sentiment_label}")

        # Respond based on detected intent and sentiment
        if intent == 0:
            cwe_id = extract_cwe_id(user_input)
            detail_type = extract_detail_type(user_input)
            print(f"Extracted CWE ID: {cwe_id}")
            print(f"Extracted detail type: {detail_type}")

            if cwe_id:
                details = get_vulnerability_details(cwe_id, detail_type)
                print(f"Retrieved details: {details}")

                if isinstance(details, dict) and 'error' in details:
                    return details['error']
                else:
                    response = f"Details for {cwe_id}:\n"
                    for key, value in details.items():
                        response += f"{key}: {value}\n"
                    return response
            else:
                return "Could not extract CWE ID from the input. Please provide a valid CWE ID."

        elif intent == 1:
            return "Implement logic for intent 1"

        return "I'm sorry, I didn't understand that. Can you please rephrase?"

    except Exception as e:
        print(f"Error occurred: {str(e)}")
        return f"An error occurred: {str(e)}"
#aj mene office ko chuti mara tha abb sone jaounga me